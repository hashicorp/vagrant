// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: proto/vagrant_server/server.proto

package vagrant_server

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VagrantClient is the client API for Vagrant service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VagrantClient interface {
	// GetVersionInfo returns information about the server. This RPC call does
	// NOT require authentication. It can be used by clients to determine if they
	// are capable of talking to this server.
	GetVersionInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetVersionInfoResponse, error)
	UpsertBasis(ctx context.Context, in *UpsertBasisRequest, opts ...grpc.CallOption) (*UpsertBasisResponse, error)
	GetBasis(ctx context.Context, in *GetBasisRequest, opts ...grpc.CallOption) (*GetBasisResponse, error)
	FindBasis(ctx context.Context, in *FindBasisRequest, opts ...grpc.CallOption) (*FindBasisResponse, error)
	ListBasis(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBasisResponse, error)
	// UpsertProject upserts the project.
	UpsertProject(ctx context.Context, in *UpsertProjectRequest, opts ...grpc.CallOption) (*UpsertProjectResponse, error)
	// GetProject returns the project.
	GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*GetProjectResponse, error)
	FindProject(ctx context.Context, in *FindProjectRequest, opts ...grpc.CallOption) (*FindProjectResponse, error)
	// ListProjects returns a list of all the projects. There is no equivalent
	// ListApplications because applications are a part of projects and you
	// can use GetProject to get more information about the project.
	ListProjects(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	// UpsertTarget upserts a target with a project. If the target
	// is already registered this does nothing.
	UpsertTarget(ctx context.Context, in *UpsertTargetRequest, opts ...grpc.CallOption) (*UpsertTargetResponse, error)
	DeleteTarget(ctx context.Context, in *DeleteTargetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*GetTargetResponse, error)
	FindTarget(ctx context.Context, in *FindTargetRequest, opts ...grpc.CallOption) (*FindTargetResponse, error)
	ListTargets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTargetsResponse, error)
	// CRUD operations for box
	UpsertBox(ctx context.Context, in *UpsertBoxRequest, opts ...grpc.CallOption) (*UpsertBoxResponse, error)
	DeleteBox(ctx context.Context, in *DeleteBoxRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetBox(ctx context.Context, in *GetBoxRequest, opts ...grpc.CallOption) (*GetBoxResponse, error)
	ListBoxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBoxesResponse, error)
	FindBox(ctx context.Context, in *FindBoxRequest, opts ...grpc.CallOption) (*FindBoxResponse, error)
	// GetLogStream reads the log stream for a deployment. This will immediately
	// send a single LogEntry with the lines we have so far. If there are no
	// available lines this will NOT block and instead will return an error.
	// The client can choose to retry or not.
	GetLogStream(ctx context.Context, in *GetLogStreamRequest, opts ...grpc.CallOption) (Vagrant_GetLogStreamClient, error)
	// QueueJob queues a job for execution by a runner. This will return as
	// soon as the job is queued, it will not wait for execution.
	QueueJob(ctx context.Context, in *QueueJobRequest, opts ...grpc.CallOption) (*QueueJobResponse, error)
	// CancelJob cancels a job. If the job is still queued this is a quick
	// and easy operation. If the job is already completed, then this does
	// nothing. If the job is assigned or running, then this will signal
	// the runner about the cancellation but it may take time.
	//
	// This RPC always returns immediately. You must use GetJob or GetJobStream
	// to wait on the status of the cancellation.
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetJob queries a job by ID.
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*Job, error)
	// INTERNAL: ListJobs lists all the jobs the server has processed. This
	// is not yet ready for public use.
	XListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error)
	// ValidateJob checks if a job appears valid. This will check the job
	// structure itself (i.e. missing fields) and can also check to ensure
	// the job is assignable to a runner.
	ValidateJob(ctx context.Context, in *ValidateJobRequest, opts ...grpc.CallOption) (*ValidateJobResponse, error)
	// GetJobStream opens a job event stream for a running job. This can be
	// used to listen for terminal output and other events of a running job.
	// Multiple listeners can open a job stream.
	GetJobStream(ctx context.Context, in *GetJobStreamRequest, opts ...grpc.CallOption) (Vagrant_GetJobStreamClient, error)
	// Clean out old jobs from the job database
	PruneOldJobs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetRunner gets information about a single runner.
	GetRunner(ctx context.Context, in *GetRunnerRequest, opts ...grpc.CallOption) (*Runner, error)
	// BootstrapToken returns the initial token for the server. This can only
	// be requested once on first startup. After initial request this will
	// always return a PermissionDenied error.
	BootstrapToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NewTokenResponse, error)
	// Generate a new invite token that users can exchange for a login token.
	GenerateInviteToken(ctx context.Context, in *InviteTokenRequest, opts ...grpc.CallOption) (*NewTokenResponse, error)
	// Generate a new login token that users can use to login directly.
	GenerateLoginToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NewTokenResponse, error)
	// Exchange a invite token for a login token.
	ConvertInviteToken(ctx context.Context, in *ConvertInviteTokenRequest, opts ...grpc.CallOption) (*NewTokenResponse, error)
	// RunnerConfig is called to register a runner and receive the configuration
	// for the runner. The response is a stream so that the configuration can
	// be updated later.
	RunnerConfig(ctx context.Context, opts ...grpc.CallOption) (Vagrant_RunnerConfigClient, error)
	// RunnerJobStream is called by a runner to request a single job for
	// execution and update the status of that job.
	RunnerJobStream(ctx context.Context, opts ...grpc.CallOption) (Vagrant_RunnerJobStreamClient, error)
}

type vagrantClient struct {
	cc grpc.ClientConnInterface
}

func NewVagrantClient(cc grpc.ClientConnInterface) VagrantClient {
	return &vagrantClient{cc}
}

func (c *vagrantClient) GetVersionInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetVersionInfoResponse, error) {
	out := new(GetVersionInfoResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetVersionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) UpsertBasis(ctx context.Context, in *UpsertBasisRequest, opts ...grpc.CallOption) (*UpsertBasisResponse, error) {
	out := new(UpsertBasisResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/UpsertBasis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetBasis(ctx context.Context, in *GetBasisRequest, opts ...grpc.CallOption) (*GetBasisResponse, error) {
	out := new(GetBasisResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetBasis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) FindBasis(ctx context.Context, in *FindBasisRequest, opts ...grpc.CallOption) (*FindBasisResponse, error) {
	out := new(FindBasisResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/FindBasis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ListBasis(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBasisResponse, error) {
	out := new(ListBasisResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ListBasis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) UpsertProject(ctx context.Context, in *UpsertProjectRequest, opts ...grpc.CallOption) (*UpsertProjectResponse, error) {
	out := new(UpsertProjectResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/UpsertProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*GetProjectResponse, error) {
	out := new(GetProjectResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) FindProject(ctx context.Context, in *FindProjectRequest, opts ...grpc.CallOption) (*FindProjectResponse, error) {
	out := new(FindProjectResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/FindProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ListProjects(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	out := new(ListProjectsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ListProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) UpsertTarget(ctx context.Context, in *UpsertTargetRequest, opts ...grpc.CallOption) (*UpsertTargetResponse, error) {
	out := new(UpsertTargetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/UpsertTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) DeleteTarget(ctx context.Context, in *DeleteTargetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/DeleteTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*GetTargetResponse, error) {
	out := new(GetTargetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) FindTarget(ctx context.Context, in *FindTargetRequest, opts ...grpc.CallOption) (*FindTargetResponse, error) {
	out := new(FindTargetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/FindTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ListTargets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTargetsResponse, error) {
	out := new(ListTargetsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ListTargets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) UpsertBox(ctx context.Context, in *UpsertBoxRequest, opts ...grpc.CallOption) (*UpsertBoxResponse, error) {
	out := new(UpsertBoxResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/UpsertBox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) DeleteBox(ctx context.Context, in *DeleteBoxRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/DeleteBox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetBox(ctx context.Context, in *GetBoxRequest, opts ...grpc.CallOption) (*GetBoxResponse, error) {
	out := new(GetBoxResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetBox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ListBoxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBoxesResponse, error) {
	out := new(ListBoxesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ListBoxes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) FindBox(ctx context.Context, in *FindBoxRequest, opts ...grpc.CallOption) (*FindBoxResponse, error) {
	out := new(FindBoxResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/FindBox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetLogStream(ctx context.Context, in *GetLogStreamRequest, opts ...grpc.CallOption) (Vagrant_GetLogStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vagrant_ServiceDesc.Streams[0], "/hashicorp.vagrant.Vagrant/GetLogStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vagrantGetLogStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vagrant_GetLogStreamClient interface {
	Recv() (*LogBatch, error)
	grpc.ClientStream
}

type vagrantGetLogStreamClient struct {
	grpc.ClientStream
}

func (x *vagrantGetLogStreamClient) Recv() (*LogBatch, error) {
	m := new(LogBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vagrantClient) QueueJob(ctx context.Context, in *QueueJobRequest, opts ...grpc.CallOption) (*QueueJobResponse, error) {
	out := new(QueueJobResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/QueueJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/CancelJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) XListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error) {
	out := new(ListJobsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/_ListJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ValidateJob(ctx context.Context, in *ValidateJobRequest, opts ...grpc.CallOption) (*ValidateJobResponse, error) {
	out := new(ValidateJobResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ValidateJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetJobStream(ctx context.Context, in *GetJobStreamRequest, opts ...grpc.CallOption) (Vagrant_GetJobStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vagrant_ServiceDesc.Streams[1], "/hashicorp.vagrant.Vagrant/GetJobStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vagrantGetJobStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vagrant_GetJobStreamClient interface {
	Recv() (*GetJobStreamResponse, error)
	grpc.ClientStream
}

type vagrantGetJobStreamClient struct {
	grpc.ClientStream
}

func (x *vagrantGetJobStreamClient) Recv() (*GetJobStreamResponse, error) {
	m := new(GetJobStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vagrantClient) PruneOldJobs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/PruneOldJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GetRunner(ctx context.Context, in *GetRunnerRequest, opts ...grpc.CallOption) (*Runner, error) {
	out := new(Runner)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GetRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) BootstrapToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NewTokenResponse, error) {
	out := new(NewTokenResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/BootstrapToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GenerateInviteToken(ctx context.Context, in *InviteTokenRequest, opts ...grpc.CallOption) (*NewTokenResponse, error) {
	out := new(NewTokenResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GenerateInviteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) GenerateLoginToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NewTokenResponse, error) {
	out := new(NewTokenResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/GenerateLoginToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) ConvertInviteToken(ctx context.Context, in *ConvertInviteTokenRequest, opts ...grpc.CallOption) (*NewTokenResponse, error) {
	out := new(NewTokenResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.Vagrant/ConvertInviteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantClient) RunnerConfig(ctx context.Context, opts ...grpc.CallOption) (Vagrant_RunnerConfigClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vagrant_ServiceDesc.Streams[2], "/hashicorp.vagrant.Vagrant/RunnerConfig", opts...)
	if err != nil {
		return nil, err
	}
	x := &vagrantRunnerConfigClient{stream}
	return x, nil
}

type Vagrant_RunnerConfigClient interface {
	Send(*RunnerConfigRequest) error
	Recv() (*RunnerConfigResponse, error)
	grpc.ClientStream
}

type vagrantRunnerConfigClient struct {
	grpc.ClientStream
}

func (x *vagrantRunnerConfigClient) Send(m *RunnerConfigRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vagrantRunnerConfigClient) Recv() (*RunnerConfigResponse, error) {
	m := new(RunnerConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vagrantClient) RunnerJobStream(ctx context.Context, opts ...grpc.CallOption) (Vagrant_RunnerJobStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vagrant_ServiceDesc.Streams[3], "/hashicorp.vagrant.Vagrant/RunnerJobStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vagrantRunnerJobStreamClient{stream}
	return x, nil
}

type Vagrant_RunnerJobStreamClient interface {
	Send(*RunnerJobStreamRequest) error
	Recv() (*RunnerJobStreamResponse, error)
	grpc.ClientStream
}

type vagrantRunnerJobStreamClient struct {
	grpc.ClientStream
}

func (x *vagrantRunnerJobStreamClient) Send(m *RunnerJobStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vagrantRunnerJobStreamClient) Recv() (*RunnerJobStreamResponse, error) {
	m := new(RunnerJobStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VagrantServer is the server API for Vagrant service.
// All implementations should embed UnimplementedVagrantServer
// for forward compatibility
type VagrantServer interface {
	// GetVersionInfo returns information about the server. This RPC call does
	// NOT require authentication. It can be used by clients to determine if they
	// are capable of talking to this server.
	GetVersionInfo(context.Context, *emptypb.Empty) (*GetVersionInfoResponse, error)
	UpsertBasis(context.Context, *UpsertBasisRequest) (*UpsertBasisResponse, error)
	GetBasis(context.Context, *GetBasisRequest) (*GetBasisResponse, error)
	FindBasis(context.Context, *FindBasisRequest) (*FindBasisResponse, error)
	ListBasis(context.Context, *emptypb.Empty) (*ListBasisResponse, error)
	// UpsertProject upserts the project.
	UpsertProject(context.Context, *UpsertProjectRequest) (*UpsertProjectResponse, error)
	// GetProject returns the project.
	GetProject(context.Context, *GetProjectRequest) (*GetProjectResponse, error)
	FindProject(context.Context, *FindProjectRequest) (*FindProjectResponse, error)
	// ListProjects returns a list of all the projects. There is no equivalent
	// ListApplications because applications are a part of projects and you
	// can use GetProject to get more information about the project.
	ListProjects(context.Context, *emptypb.Empty) (*ListProjectsResponse, error)
	// UpsertTarget upserts a target with a project. If the target
	// is already registered this does nothing.
	UpsertTarget(context.Context, *UpsertTargetRequest) (*UpsertTargetResponse, error)
	DeleteTarget(context.Context, *DeleteTargetRequest) (*emptypb.Empty, error)
	GetTarget(context.Context, *GetTargetRequest) (*GetTargetResponse, error)
	FindTarget(context.Context, *FindTargetRequest) (*FindTargetResponse, error)
	ListTargets(context.Context, *emptypb.Empty) (*ListTargetsResponse, error)
	// CRUD operations for box
	UpsertBox(context.Context, *UpsertBoxRequest) (*UpsertBoxResponse, error)
	DeleteBox(context.Context, *DeleteBoxRequest) (*emptypb.Empty, error)
	GetBox(context.Context, *GetBoxRequest) (*GetBoxResponse, error)
	ListBoxes(context.Context, *emptypb.Empty) (*ListBoxesResponse, error)
	FindBox(context.Context, *FindBoxRequest) (*FindBoxResponse, error)
	// GetLogStream reads the log stream for a deployment. This will immediately
	// send a single LogEntry with the lines we have so far. If there are no
	// available lines this will NOT block and instead will return an error.
	// The client can choose to retry or not.
	GetLogStream(*GetLogStreamRequest, Vagrant_GetLogStreamServer) error
	// QueueJob queues a job for execution by a runner. This will return as
	// soon as the job is queued, it will not wait for execution.
	QueueJob(context.Context, *QueueJobRequest) (*QueueJobResponse, error)
	// CancelJob cancels a job. If the job is still queued this is a quick
	// and easy operation. If the job is already completed, then this does
	// nothing. If the job is assigned or running, then this will signal
	// the runner about the cancellation but it may take time.
	//
	// This RPC always returns immediately. You must use GetJob or GetJobStream
	// to wait on the status of the cancellation.
	CancelJob(context.Context, *CancelJobRequest) (*emptypb.Empty, error)
	// GetJob queries a job by ID.
	GetJob(context.Context, *GetJobRequest) (*Job, error)
	// INTERNAL: ListJobs lists all the jobs the server has processed. This
	// is not yet ready for public use.
	XListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error)
	// ValidateJob checks if a job appears valid. This will check the job
	// structure itself (i.e. missing fields) and can also check to ensure
	// the job is assignable to a runner.
	ValidateJob(context.Context, *ValidateJobRequest) (*ValidateJobResponse, error)
	// GetJobStream opens a job event stream for a running job. This can be
	// used to listen for terminal output and other events of a running job.
	// Multiple listeners can open a job stream.
	GetJobStream(*GetJobStreamRequest, Vagrant_GetJobStreamServer) error
	// Clean out old jobs from the job database
	PruneOldJobs(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetRunner gets information about a single runner.
	GetRunner(context.Context, *GetRunnerRequest) (*Runner, error)
	// BootstrapToken returns the initial token for the server. This can only
	// be requested once on first startup. After initial request this will
	// always return a PermissionDenied error.
	BootstrapToken(context.Context, *emptypb.Empty) (*NewTokenResponse, error)
	// Generate a new invite token that users can exchange for a login token.
	GenerateInviteToken(context.Context, *InviteTokenRequest) (*NewTokenResponse, error)
	// Generate a new login token that users can use to login directly.
	GenerateLoginToken(context.Context, *emptypb.Empty) (*NewTokenResponse, error)
	// Exchange a invite token for a login token.
	ConvertInviteToken(context.Context, *ConvertInviteTokenRequest) (*NewTokenResponse, error)
	// RunnerConfig is called to register a runner and receive the configuration
	// for the runner. The response is a stream so that the configuration can
	// be updated later.
	RunnerConfig(Vagrant_RunnerConfigServer) error
	// RunnerJobStream is called by a runner to request a single job for
	// execution and update the status of that job.
	RunnerJobStream(Vagrant_RunnerJobStreamServer) error
}

// UnimplementedVagrantServer should be embedded to have forward compatible implementations.
type UnimplementedVagrantServer struct {
}

func (UnimplementedVagrantServer) GetVersionInfo(context.Context, *emptypb.Empty) (*GetVersionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionInfo not implemented")
}
func (UnimplementedVagrantServer) UpsertBasis(context.Context, *UpsertBasisRequest) (*UpsertBasisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertBasis not implemented")
}
func (UnimplementedVagrantServer) GetBasis(context.Context, *GetBasisRequest) (*GetBasisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasis not implemented")
}
func (UnimplementedVagrantServer) FindBasis(context.Context, *FindBasisRequest) (*FindBasisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindBasis not implemented")
}
func (UnimplementedVagrantServer) ListBasis(context.Context, *emptypb.Empty) (*ListBasisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBasis not implemented")
}
func (UnimplementedVagrantServer) UpsertProject(context.Context, *UpsertProjectRequest) (*UpsertProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertProject not implemented")
}
func (UnimplementedVagrantServer) GetProject(context.Context, *GetProjectRequest) (*GetProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (UnimplementedVagrantServer) FindProject(context.Context, *FindProjectRequest) (*FindProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindProject not implemented")
}
func (UnimplementedVagrantServer) ListProjects(context.Context, *emptypb.Empty) (*ListProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (UnimplementedVagrantServer) UpsertTarget(context.Context, *UpsertTargetRequest) (*UpsertTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertTarget not implemented")
}
func (UnimplementedVagrantServer) DeleteTarget(context.Context, *DeleteTargetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTarget not implemented")
}
func (UnimplementedVagrantServer) GetTarget(context.Context, *GetTargetRequest) (*GetTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTarget not implemented")
}
func (UnimplementedVagrantServer) FindTarget(context.Context, *FindTargetRequest) (*FindTargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTarget not implemented")
}
func (UnimplementedVagrantServer) ListTargets(context.Context, *emptypb.Empty) (*ListTargetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTargets not implemented")
}
func (UnimplementedVagrantServer) UpsertBox(context.Context, *UpsertBoxRequest) (*UpsertBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertBox not implemented")
}
func (UnimplementedVagrantServer) DeleteBox(context.Context, *DeleteBoxRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBox not implemented")
}
func (UnimplementedVagrantServer) GetBox(context.Context, *GetBoxRequest) (*GetBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBox not implemented")
}
func (UnimplementedVagrantServer) ListBoxes(context.Context, *emptypb.Empty) (*ListBoxesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBoxes not implemented")
}
func (UnimplementedVagrantServer) FindBox(context.Context, *FindBoxRequest) (*FindBoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindBox not implemented")
}
func (UnimplementedVagrantServer) GetLogStream(*GetLogStreamRequest, Vagrant_GetLogStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLogStream not implemented")
}
func (UnimplementedVagrantServer) QueueJob(context.Context, *QueueJobRequest) (*QueueJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueueJob not implemented")
}
func (UnimplementedVagrantServer) CancelJob(context.Context, *CancelJobRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedVagrantServer) GetJob(context.Context, *GetJobRequest) (*Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedVagrantServer) XListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method XListJobs not implemented")
}
func (UnimplementedVagrantServer) ValidateJob(context.Context, *ValidateJobRequest) (*ValidateJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateJob not implemented")
}
func (UnimplementedVagrantServer) GetJobStream(*GetJobStreamRequest, Vagrant_GetJobStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetJobStream not implemented")
}
func (UnimplementedVagrantServer) PruneOldJobs(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PruneOldJobs not implemented")
}
func (UnimplementedVagrantServer) GetRunner(context.Context, *GetRunnerRequest) (*Runner, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunner not implemented")
}
func (UnimplementedVagrantServer) BootstrapToken(context.Context, *emptypb.Empty) (*NewTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootstrapToken not implemented")
}
func (UnimplementedVagrantServer) GenerateInviteToken(context.Context, *InviteTokenRequest) (*NewTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateInviteToken not implemented")
}
func (UnimplementedVagrantServer) GenerateLoginToken(context.Context, *emptypb.Empty) (*NewTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateLoginToken not implemented")
}
func (UnimplementedVagrantServer) ConvertInviteToken(context.Context, *ConvertInviteTokenRequest) (*NewTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertInviteToken not implemented")
}
func (UnimplementedVagrantServer) RunnerConfig(Vagrant_RunnerConfigServer) error {
	return status.Errorf(codes.Unimplemented, "method RunnerConfig not implemented")
}
func (UnimplementedVagrantServer) RunnerJobStream(Vagrant_RunnerJobStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method RunnerJobStream not implemented")
}

// UnsafeVagrantServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VagrantServer will
// result in compilation errors.
type UnsafeVagrantServer interface {
	mustEmbedUnimplementedVagrantServer()
}

func RegisterVagrantServer(s grpc.ServiceRegistrar, srv VagrantServer) {
	s.RegisterService(&Vagrant_ServiceDesc, srv)
}

func _Vagrant_GetVersionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetVersionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetVersionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetVersionInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_UpsertBasis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertBasisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).UpsertBasis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/UpsertBasis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).UpsertBasis(ctx, req.(*UpsertBasisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetBasis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBasisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetBasis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetBasis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetBasis(ctx, req.(*GetBasisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_FindBasis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindBasisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).FindBasis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/FindBasis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).FindBasis(ctx, req.(*FindBasisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ListBasis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ListBasis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ListBasis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ListBasis(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_UpsertProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).UpsertProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/UpsertProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).UpsertProject(ctx, req.(*UpsertProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetProject(ctx, req.(*GetProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_FindProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).FindProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/FindProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).FindProject(ctx, req.(*FindProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ListProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ListProjects(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_UpsertTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).UpsertTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/UpsertTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).UpsertTarget(ctx, req.(*UpsertTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_DeleteTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).DeleteTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/DeleteTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).DeleteTarget(ctx, req.(*DeleteTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetTarget(ctx, req.(*GetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_FindTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).FindTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/FindTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).FindTarget(ctx, req.(*FindTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ListTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ListTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ListTargets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ListTargets(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_UpsertBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).UpsertBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/UpsertBox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).UpsertBox(ctx, req.(*UpsertBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_DeleteBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).DeleteBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/DeleteBox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).DeleteBox(ctx, req.(*DeleteBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetBox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetBox(ctx, req.(*GetBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ListBoxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ListBoxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ListBoxes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ListBoxes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_FindBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).FindBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/FindBox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).FindBox(ctx, req.(*FindBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetLogStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VagrantServer).GetLogStream(m, &vagrantGetLogStreamServer{stream})
}

type Vagrant_GetLogStreamServer interface {
	Send(*LogBatch) error
	grpc.ServerStream
}

type vagrantGetLogStreamServer struct {
	grpc.ServerStream
}

func (x *vagrantGetLogStreamServer) Send(m *LogBatch) error {
	return x.ServerStream.SendMsg(m)
}

func _Vagrant_QueueJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).QueueJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/QueueJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).QueueJob(ctx, req.(*QueueJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_XListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).XListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/_ListJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).XListJobs(ctx, req.(*ListJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ValidateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ValidateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ValidateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ValidateJob(ctx, req.(*ValidateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetJobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VagrantServer).GetJobStream(m, &vagrantGetJobStreamServer{stream})
}

type Vagrant_GetJobStreamServer interface {
	Send(*GetJobStreamResponse) error
	grpc.ServerStream
}

type vagrantGetJobStreamServer struct {
	grpc.ServerStream
}

func (x *vagrantGetJobStreamServer) Send(m *GetJobStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vagrant_PruneOldJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).PruneOldJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/PruneOldJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).PruneOldJobs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GetRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GetRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GetRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GetRunner(ctx, req.(*GetRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_BootstrapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).BootstrapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/BootstrapToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).BootstrapToken(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GenerateInviteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GenerateInviteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GenerateInviteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GenerateInviteToken(ctx, req.(*InviteTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_GenerateLoginToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).GenerateLoginToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/GenerateLoginToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).GenerateLoginToken(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_ConvertInviteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertInviteTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantServer).ConvertInviteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.Vagrant/ConvertInviteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantServer).ConvertInviteToken(ctx, req.(*ConvertInviteTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vagrant_RunnerConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VagrantServer).RunnerConfig(&vagrantRunnerConfigServer{stream})
}

type Vagrant_RunnerConfigServer interface {
	Send(*RunnerConfigResponse) error
	Recv() (*RunnerConfigRequest, error)
	grpc.ServerStream
}

type vagrantRunnerConfigServer struct {
	grpc.ServerStream
}

func (x *vagrantRunnerConfigServer) Send(m *RunnerConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vagrantRunnerConfigServer) Recv() (*RunnerConfigRequest, error) {
	m := new(RunnerConfigRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Vagrant_RunnerJobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VagrantServer).RunnerJobStream(&vagrantRunnerJobStreamServer{stream})
}

type Vagrant_RunnerJobStreamServer interface {
	Send(*RunnerJobStreamResponse) error
	Recv() (*RunnerJobStreamRequest, error)
	grpc.ServerStream
}

type vagrantRunnerJobStreamServer struct {
	grpc.ServerStream
}

func (x *vagrantRunnerJobStreamServer) Send(m *RunnerJobStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vagrantRunnerJobStreamServer) Recv() (*RunnerJobStreamRequest, error) {
	m := new(RunnerJobStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Vagrant_ServiceDesc is the grpc.ServiceDesc for Vagrant service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vagrant_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.Vagrant",
	HandlerType: (*VagrantServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersionInfo",
			Handler:    _Vagrant_GetVersionInfo_Handler,
		},
		{
			MethodName: "UpsertBasis",
			Handler:    _Vagrant_UpsertBasis_Handler,
		},
		{
			MethodName: "GetBasis",
			Handler:    _Vagrant_GetBasis_Handler,
		},
		{
			MethodName: "FindBasis",
			Handler:    _Vagrant_FindBasis_Handler,
		},
		{
			MethodName: "ListBasis",
			Handler:    _Vagrant_ListBasis_Handler,
		},
		{
			MethodName: "UpsertProject",
			Handler:    _Vagrant_UpsertProject_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _Vagrant_GetProject_Handler,
		},
		{
			MethodName: "FindProject",
			Handler:    _Vagrant_FindProject_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _Vagrant_ListProjects_Handler,
		},
		{
			MethodName: "UpsertTarget",
			Handler:    _Vagrant_UpsertTarget_Handler,
		},
		{
			MethodName: "DeleteTarget",
			Handler:    _Vagrant_DeleteTarget_Handler,
		},
		{
			MethodName: "GetTarget",
			Handler:    _Vagrant_GetTarget_Handler,
		},
		{
			MethodName: "FindTarget",
			Handler:    _Vagrant_FindTarget_Handler,
		},
		{
			MethodName: "ListTargets",
			Handler:    _Vagrant_ListTargets_Handler,
		},
		{
			MethodName: "UpsertBox",
			Handler:    _Vagrant_UpsertBox_Handler,
		},
		{
			MethodName: "DeleteBox",
			Handler:    _Vagrant_DeleteBox_Handler,
		},
		{
			MethodName: "GetBox",
			Handler:    _Vagrant_GetBox_Handler,
		},
		{
			MethodName: "ListBoxes",
			Handler:    _Vagrant_ListBoxes_Handler,
		},
		{
			MethodName: "FindBox",
			Handler:    _Vagrant_FindBox_Handler,
		},
		{
			MethodName: "QueueJob",
			Handler:    _Vagrant_QueueJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _Vagrant_CancelJob_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _Vagrant_GetJob_Handler,
		},
		{
			MethodName: "_ListJobs",
			Handler:    _Vagrant_XListJobs_Handler,
		},
		{
			MethodName: "ValidateJob",
			Handler:    _Vagrant_ValidateJob_Handler,
		},
		{
			MethodName: "PruneOldJobs",
			Handler:    _Vagrant_PruneOldJobs_Handler,
		},
		{
			MethodName: "GetRunner",
			Handler:    _Vagrant_GetRunner_Handler,
		},
		{
			MethodName: "BootstrapToken",
			Handler:    _Vagrant_BootstrapToken_Handler,
		},
		{
			MethodName: "GenerateInviteToken",
			Handler:    _Vagrant_GenerateInviteToken_Handler,
		},
		{
			MethodName: "GenerateLoginToken",
			Handler:    _Vagrant_GenerateLoginToken_Handler,
		},
		{
			MethodName: "ConvertInviteToken",
			Handler:    _Vagrant_ConvertInviteToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetLogStream",
			Handler:       _Vagrant_GetLogStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobStream",
			Handler:       _Vagrant_GetJobStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunnerConfig",
			Handler:       _Vagrant_RunnerConfig_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RunnerJobStream",
			Handler:       _Vagrant_RunnerJobStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/vagrant_server/server.proto",
}
